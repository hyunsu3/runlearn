let words = [
  { word: "commitment", meaning: "Ï†ÑÎÖê, ÏïΩÏÜç" },
  { word: "correlated with", meaning: "~ÏôÄ Ïó∞Í¥ÄÏù¥ ÏûàÎäî" },
  { word: "contribute", meaning: "Í∏∞Ïó¨ÌïòÎã§" },
  { word: "reduction", meaning: "Í∞êÏÜå" },
  { word: "anxiety", meaning: "Î∂àÏïà" },
  { word: "resilience", meaning: "ÌöåÎ≥µÎ†•" },
  { word: "generate", meaning: "ÏÉùÏÇ∞ÌïòÎã§" },
  { word: "responsible for", meaning: "~Ïóê Ï±ÖÏûÑÏù¥ ÏûàÎäî" },
  { word: "relevant", meaning: "Í¥ÄÎ†®Ïù¥ ÏûàÎäî" },
  { word: "embrace", meaning: "Î∞õÏïÑÎì§Ïù¥Îã§" },
  { word: "resist", meaning: "Ï†ÄÌï≠ÌïòÎã§" },
  { word: "observe", meaning: "Í¥ÄÏ∞∞ÌïòÎã§" },
  { word: "absorb", meaning: "Ìù°ÏàòÌïòÎã§" },
  { word: "transform", meaning: "Î≥ÄÌòïÌïòÎã§" },
  { word: "overrate", meaning: "Í≥ºÎåÄÌèâÍ∞ÄÌïòÎã§" },
  { word: "enable", meaning: "~ÏùÑ Í∞ÄÎä•ÌïòÍ≤å ÌïòÎã§" },
  { word: "function", meaning: "Í∏∞Îä•" },
  { word: "substitute", meaning: "ÎåÄÏ≤¥ÌïòÎã§" },
  { word: "overlook", meaning: "Í∞ÑÍ≥ºÌïòÎã§" },
  { word: "implication", meaning: "ÏòÅÌñ•" },
  { word: "implement", meaning: "Ïã§Ìñâ" },
  { word: "guide", meaning: "Ïù¥ÎÅåÎã§" },
  { word: "competitive", meaning: "Í≤ΩÏüÅÎ†• ÏûàÎäî" },
  { word: "consciously", meaning: "ÏùòÏãùÏ†ÅÏúºÎ°ú" },
  { word: "nurture", meaning: "ÏñëÏú°ÌïòÎã§, Í∞ÄÎ•¥ÏπòÎã§" },
  { word: "uniformity", meaning: "ÌöçÏùºÏÑ±" },
  { word: "obedience", meaning: "Î≥µÏ¢Ö" },
  { word: "right", meaning: "Í∂åÎ¶¨" },
  { word: "secure", meaning: "ÏïàÏ†ÑÌïú" },
  { word: "evaluate", meaning: "ÌèâÍ∞ÄÌïòÎã§" },
  { word: "improve", meaning: "Í∞úÏÑ†ÌïòÎã§" },
  { word: "occupy", meaning: "Ï∞®ÏßÄÌïòÎã§" },
  { word: "ethical", meaning: "Ïú§Î¶¨Ï†ÅÏù∏" },
  { word: "responsibility", meaning: "Ï±ÖÏûÑ" },
];

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

let currentWordObj = null; // üîπ ÌòÑÏû¨ Ï∂úÏ†úÎêú Îã®Ïñ¥ Ï†ÄÏû• Î≥ÄÏàò
let lastWordObj = null; // üîπ Î∞îÎ°ú ÏßÅÏ†Ñ Î¨∏Ï†ú Î∞©ÏßÄ Î≥ÄÏàò
let wordScores = {}; // üîπ Îã®Ïñ¥Î≥Ñ Ï†êÏàò Ï†ÄÏû•
const PASS_THRESHOLD = 1; // üîπ Ìå®Ïä§ Í∏∞Ï§Ä Í∞ÄÏÇ∞Ï†ê

function startGame() {
  console.log("=== Í≤åÏûÑ ÏãúÏûë ===");
  console.log(
    "Ï†ÑÏ≤¥ Îã®Ïñ¥ Î∞∞Ïó¥ (words):",
    words.map((w) => w.word)
  );
  console.log("ÌòÑÏû¨ wordScores ÏÉÅÌÉú:", wordScores);
  console.log("PASS_THRESHOLD:", PASS_THRESHOLD);

  // üîπ Î™®Îì† Îã®Ïñ¥Í∞Ä Ìå®Ïä§ Í∏∞Ï§ÄÏùÑ ÎÑòÏúºÎ©¥ Ï¢ÖÎ£å (Í≥µÎ∞± Ï†úÍ±∞ ÌõÑ Í∞ÄÏÇ∞Ï†ê Ï°∞Ìöå)
  let remainingWords = words.filter((w) => {
    let cleanWord = w.word.trim().replace(/\s/g, ""); // Í≥µÎ∞± Ï†úÍ±∞
    let score = wordScores[cleanWord] || 0;
    console.log(`Îã®Ïñ¥: ${w.word} (Ï†ïÎ¶¨Îêú: ${cleanWord}), Ï†êÏàò: ${score}, Ìå®Ïä§ Í∏∞Ï§Ä(${PASS_THRESHOLD}) ÎπÑÍµê: ${score < PASS_THRESHOLD}`);
    return score < PASS_THRESHOLD;
  });

  console.log(
    "ÌïÑÌÑ∞ÎßÅÎêú remainingWords:",
    remainingWords.map((w) => w.word)
  );

  if (remainingWords.length === 0) {
    alert("Î™®Îì† Î¨∏Ï†úÎ•º Ïûò ÌíÄÏóàÏñ¥Ïöî! Ï∂ïÌïòÌï©ÎãàÎã§! üéâ");
    return;
  }

  // üîπ Î∞îÎ°ú ÏßÅÏ†Ñ Î¨∏Ï†úÏôÄ Îã§Î•∏ Îã®Ïñ¥ ÏÑ†ÌÉù
  let availableWords = remainingWords.filter((w) => w !== lastWordObj);
  console.log(
    "ÌïÑÌÑ∞ÎßÅÎêú availableWords (ÏßÅÏ†Ñ Îã®Ïñ¥ Ï†úÏô∏):",
    availableWords.map((w) => w.word)
  );

  // üîπ ÎÇ®ÏùÄ Îã®Ïñ¥Í∞Ä ÌïòÎÇòÎøêÏù¥ÎùºÎ©¥ Í∑∏ Îã®Ïñ¥ÎùºÎèÑ Ï∂úÏ†ú
  if (availableWords.length === 0) {
    if (remainingWords.length === 1) {
      availableWords = remainingWords;
      console.log("‚ö†Ô∏è ÎÇ®ÏùÄ Îã®Ïñ¥Í∞Ä ÌïòÎÇòÎøêÏù¥ÎØÄÎ°ú Ìï¥Îãπ Îã®Ïñ¥ ÏÑ†ÌÉù:", availableWords[0].word);
    } else {
      availableWords = remainingWords.filter((w) => w !== lastWordObj);
    }
  }

  // üîπ ÏÑ†ÌÉùÎêú Îã®Ïñ¥ Ï∂úÎ†• (Í≥µÎ∞± Ï†úÍ±∞ ÌõÑ Ï†êÏàò ÌôïÏù∏)
  currentWordObj = availableWords[Math.floor(Math.random() * availableWords.length)];
  lastWordObj = currentWordObj;

  let cleanSelectedWord = currentWordObj.word.trim().replace(/\s/g, "");
  console.log(`‚úÖ ÏÑ†ÌÉùÎêú Îã®Ïñ¥: ${currentWordObj.word}, ÌòÑÏû¨ Ï†êÏàò: ${wordScores[cleanSelectedWord] || 0}`);

  let word = currentWordObj.word;
  let meaning = currentWordObj.meaning;

  document.querySelector(".word-meaning").textContent = `Îúª: ${meaning}`;
  document.querySelector(".slots").innerHTML = "";
  document.querySelector(".stickers").innerHTML = "";

  let letters = word.split("");
  let revealedLetters = new Map();

  letters.forEach((letter, index) => {
    let slot = document.createElement("div");
    slot.classList.add("slot");

    if (letter === " ") {
      slot.classList.add("empty");
      slot.textContent = "";
    } else if (Math.random() < 0.4) {
      slot.textContent = letter;
      slot.style.color = "black";
      revealedLetters.set(index, letter);
    } else {
      slot.dataset.index = index;
    }
    document.querySelector(".slots").appendChild(slot);
  });

  let filteredLetters = letters.filter((_, index) => !revealedLetters.has(index) && letters[index] !== " ");
  let shuffledLetters = shuffle(filteredLetters.filter((letter) => letter !== " "));

  let stickerContainer = document.querySelector(".stickers");
  stickerContainer.style.position = "relative";
  stickerContainer.style.height = "120px";
  stickerContainer.style.width = "100%";

  let stickerCount = shuffledLetters.length;
  let maxPerRow = stickerContainer.clientWidth >= 450 ? 8 : 6;
  let rowCount = Math.ceil(stickerCount / maxPerRow);

  let stickerSize = 40;
  let gap = 10;
  let rowHeight = stickerSize + gap;

  stickerContainer.style.height = `${rowCount * rowHeight}px`;

  shuffledLetters.forEach((letter, index) => {
    let sticker = document.createElement("div");
    sticker.classList.add("sticker");
    sticker.textContent = letter;
    sticker.style.position = "absolute";

    let row = Math.floor(index / maxPerRow);
    let col = index % maxPerRow;
    let totalInRow = Math.min(stickerCount - row * maxPerRow, maxPerRow);
    let rowWidth = totalInRow * (stickerSize + gap) - gap;
    let startX = (stickerContainer.clientWidth - rowWidth) / 2;

    let x = startX + col * (stickerSize + gap);
    let y = row * rowHeight;

    sticker.style.left = `${x}px`;
    sticker.style.top = `${y}px`;

    sticker.onclick = function () {
      let emptySlot = document.querySelector(".slot[data-index]");
      if (emptySlot) {
        emptySlot.textContent = letter;
        emptySlot.style.color = "#aaa";
        emptySlot.removeAttribute("data-index");
        sticker.remove();

        if (!document.querySelector(".slot[data-index]")) {
          checkAnswer();
        }
      }
    };

    stickerContainer.appendChild(sticker);
  });
}

function checkAnswer() {
  let slots = Array.from(document.querySelectorAll(".slot"));

  if (slots.filter((slot) => !slot.classList.contains("empty")).some((slot) => slot.textContent === "")) return;

  let answer = slots
    .map((s) => s.textContent)
    .join(" ")
    .replace(/ /g, "");
  let correctAnswer = currentWordObj.word.replace(/ /g, "");

  console.log("ÏÇ¨Ïö©ÏûêÍ∞Ä ÏûÖÎ†•Ìïú Îã®Ïñ¥:", `"${answer}"`);
  console.log("Ï†ïÎãµ Îã®Ïñ¥:", `"${correctAnswer}"`);

  let cleanWord = currentWordObj.word.trim().replace(/\s/g, "");

  if (answer === correctAnswer) {
    slots.forEach((slot) => {
      slot.style.color = "black";
      slot.style.border = "none";
    });

    wordScores[cleanWord] = (wordScores[cleanWord] || 0) + 1;
    console.log(`‚úÖ Ï†ïÎãµ! ÌòÑÏû¨ Ï†êÏàò: ${wordScores[cleanWord]}`);

    const audioEngFile = `Audio/${currentWordObj.word.replace(/ /g, "_")}.mp3`;
    const audioKorFile = `Audio/${currentWordObj.word.replace(/ /g, "_")}_kor.mp3`;

    let audioEng = new Audio(audioEngFile);
    let audioKor = new Audio(audioKorFile);

    audioEng.play();
    setTimeout(startGame, 2000);
  } else {
    // üîπ ÌãÄÎ†∏ÏùÑ Í≤ΩÏö∞ -1Ï†ê Î∞òÏòÅ (0Ï†ê Ïù¥Ìïò Ï†úÌïú Ï†úÍ±∞)
    wordScores[cleanWord] = (wordScores[cleanWord] || 0) - 1;
    console.log(`‚ùå Ïò§Îãµ! ÌòÑÏû¨ Ï†êÏàò: ${wordScores[cleanWord]}`);

    // üîπ Í≥µÎ∞±ÏùÑ Ï†úÍ±∞Ìïú Î∞∞Ïó¥ ÏÉùÏÑ± (Í≥µÎ∞± Ìè¨Ìï®Îêú ÏõêÎûò Ïä¨Î°Ø ÎπÑÍµêÏö©)
    let correctWordArray = currentWordObj.word.replace(/ /g, "").split("");
    let userWordArray = slots
      .map((s) => s.textContent)
      .join("")
      .replace(/ /g, "")
      .split("");

    console.log("ÏÇ¨Ïö©Ïûê ÏûÖÎ†• Î∞∞Ïó¥:", userWordArray);
    console.log("Ï†ïÎãµ Î∞∞Ïó¥:", correctWordArray);

    let incorrectLetters = []; // ÌãÄÎ¶∞ Í∏ÄÏûêÎ•º Ï†ÄÏû•Ìï† Î∞∞Ïó¥

    let userIndex = 0; // ÏÇ¨Ïö©Ïûê ÏûÖÎ†• Î∞∞Ïó¥ Ïù∏Îç±Ïä§ (Í≥µÎ∞± Ï†úÏô∏)
    slots.forEach((slot) => {
      if (!slot.classList.contains("empty")) {
        if (userWordArray[userIndex] !== correctWordArray[userIndex]) {
          slot.style.color = "red"; // ‚ùå ÌãÄÎ¶∞ Í∏ÄÏûê Îπ®Í∞ÑÏÉâ
          incorrectLetters.push(slot.textContent.trim()); // ÌãÄÎ¶∞ Í∏ÄÏûê Ï†ÄÏû•
        } else {
          slot.style.color = "black"; // ‚úÖ ÎßûÏùÄ Í∏ÄÏûêÎäî Í≤ÄÏ†ïÏÉâ Ïú†ÏßÄ
        }
        userIndex++; // Í≥µÎ∞±Ïù¥ ÏïÑÎãå Í∏ÄÏûêÎßå Ï¶ùÍ∞Ä
      }
    });

    setTimeout(() => {
      document.querySelector(".stickers").innerHTML = ""; // Í∏∞Ï°¥ Ïä§Ìã∞Ïª§ Ï¥àÍ∏∞Ìôî

      userIndex = 0; // Îã§Ïãú ÏÇ¨Ïö©Ïûê Ïù∏Îç±Ïä§ Ï¥àÍ∏∞Ìôî
      slots.forEach((slot) => {
        if (!slot.classList.contains("empty")) {
          if (userWordArray[userIndex] !== correctWordArray[userIndex]) {
            slot.textContent = ""; // ÌãÄÎ¶∞ Í∏ÄÏûêÎßå Ï†úÍ±∞
            slot.dataset.index = "";
            slot.style.color = "#aaa";
          }
          userIndex++; // Í≥µÎ∞±Ïù¥ ÏïÑÎãå Í∏ÄÏûêÎßå Ï¶ùÍ∞Ä
        }
      });

      incorrectLetters.forEach((letter) => {
        let sticker = document.createElement("div");
        sticker.classList.add("sticker");
        sticker.textContent = letter;
        sticker.onclick = function () {
          let emptySlot = document.querySelector(".slot[data-index]");
          if (emptySlot) {
            emptySlot.textContent = letter;
            emptySlot.style.color = "#aaa"; // üîπ ÏûÖÎ†•Îêú Í∏ÄÏûêÎèÑ ÌöåÏÉâÏúºÎ°ú Ïú†ÏßÄ
            emptySlot.removeAttribute("data-index");
            sticker.remove();
            if (!document.querySelector(".slot[data-index]")) {
              checkAnswer();
            }
          }
        };
        document.querySelector(".stickers").appendChild(sticker);
      });
    }, 1000);
  }
}

startGame();
